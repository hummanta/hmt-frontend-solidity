use crate::ast::*;
use crate::error::LexicalError;
use crate::token::Token;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, LexicalError>>);

pub Program: Program = {
    SourceUnit* => Program(<>)
}

SourceUnit: SourceUnit = {
    PragmaDirective => SourceUnit::PragmaDirective(<>.into()),
    ContractDefinition => SourceUnit::ContractDefinition(<>),
}

PragmaDirective: PragmaDirective = {
    "pragma" <i:Identifier> <comp:VersionComparator1+> ";" => {
        PragmaDirective::Version(i, comp)
    }
}

VersionComparator1: VersionComparator = {
    <left:VersionComparator1> "||" <right:VersionComparator> => VersionComparator::Or {
        left: left.into(),
        right: right.into()
    },
    VersionComparator
}

VersionComparator: VersionComparator = {
    <version:Version> => VersionComparator::Plain {version},
    <op:VersionOp> <version:Version> => VersionComparator::Operator { op, version },
    <from:Version> "-" <to:Version> => VersionComparator::Range { from, to },
}

Version: String = {
    <v: number> => v.to_string()
}

VersionOp: VersionOp = {
    "=" => VersionOp::Exact,
    ">" => VersionOp::Greater,
    ">=" => VersionOp::GreaterEq,
    "<" => VersionOp::Less,
    "<=" => VersionOp::LessEq,
    "~" => VersionOp::Tilde,
    "^" => VersionOp::Caret,
    "*" => VersionOp::Wildcard,
}

ContractDefinition: Box<ContractDefinition> = {
    <ty:ContractTy> <name:Identifier> "{" "}" => {
        Box::new(ContractDefinition{ ty, name, parts: Vec::new() })
    }
}

ContractTy: ContractTy = {
    "contract" => ContractTy::Contract,
}



Identifier: Identifier = {
    <n:identifier> => Identifier{ name: n.to_string() }
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        identifier => Token::Identifier(<String>),
        annotation => Token::Annotation(<String>),
        string => Token::StringLiteral(<String>),
        hexstring => Token::HexLiteral(<String>),
        address => Token::AddressLiteral(<String>),
        number => Token::Number(<f64>),
        rational => Token::RationalNumber(<String>),
        hexnumber => Token::HexNumber(<String>),

        ";" => Token::Semicolon,
        "{" => Token::OpenCurlyBrace,
        "}" => Token::CloseCurlyBrace,
        "(" => Token::OpenParenthesis,
        ")" => Token::CloseParenthesis,
        "=" => Token::Assign,
        "==" => Token::Equal,
        "=>" => Token::Arrow,
        "->" => Token::YulArrow,
        "|=" => Token::BitwiseOrAssign,
        "^=" => Token::BitwiseXorAssign,
        "&=" => Token::BitwiseAndAssign,
        "<<=" => Token::ShiftLeftAssign,
        ">>=" => Token::ShiftRightAssign,
        "+=" => Token::AddAssign,
        "-=" => Token::SubtractAssign,
        "*=" => Token::MulAssign,
        "/=" => Token::DivideAssign,
        "%=" => Token::ModuloAssign,
        "?" => Token::Question,
        ":" => Token::Colon,
        ":=" => Token::ColonAssign,
        "||" => Token::Or,
        "&&" => Token::And,
        "!=" => Token::NotEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        ">" => Token::More,
        ">=" => Token::MoreEqual,
        "|" => Token::BitwiseOr,
        "&" => Token::BitwiseAnd,
        "^" => Token::BitwiseXor,
        "<<" => Token::ShiftLeft,
        ">>" => Token::ShiftRight,
        "+" => Token::Add,
        "-" => Token::Subtract,
        "*" => Token::Mul,
        "/" => Token::Divide,
        "%" => Token::Modulo,
        "**" => Token::Power,
        "!" => Token::Not,
        "~" => Token::BitwiseNot,
        "++" => Token::Increment,
        "--" => Token::Decrement,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "." => Token::Member,
        "," => Token::Comma,
        Uint => Token::Uint(<u16>),
        Int => Token::Int(<u16>),
        Bytes => Token::Bytes(<u8>),
        "byte" => Token::Byte,
        "struct" => Token::Struct,
        "memory" => Token::Memory,
        "calldata" => Token::Calldata,
        "storage" => Token::Storage,
        "import" => Token::Import,
        "contract" => Token::Contract,
        "pragma" => Token::Pragma,
        "bool" => Token::Bool,
        "address" => Token::Address,
        "string" => Token::String,
        "bytes" => Token::DynamicBytes,
        "delete" => Token::Delete,
        "new" => Token::New,
        "interface" => Token::Interface,
        "library" => Token::Library,
        "event" => Token::Event,
        "enum" => Token::Enum,
        "type" => Token::Type,
        "public" => Token::Public,
        "private" => Token::Private,
        "external" => Token::External,
        "internal" => Token::Internal,
        "constant" => Token::Constant,
        "true" => Token::True,
        "false" => Token::False,
        "pure" => Token::Pure,
        "view" => Token::View,
        "payable" => Token::Payable,
        "constructor" => Token::Constructor,
        "function" => Token::Function,
        "returns" => Token::Returns,
        "return" => Token::Return,
        "revert" => Token::Revert,
        "if" => Token::If,
        "for" => Token::For,
        "while" => Token::While,
        "else" => Token::Else,
        "do" => Token::Do,
        "continue" => Token::Continue,
        "break" => Token::Break,
        "throw" => Token::Throw,
        "emit" => Token::Emit,
        "anonymous" => Token::Anonymous,
        "indexed" => Token::Indexed,
        "mapping" => Token::Mapping,
        "try" => Token::Try,
        "catch" => Token::Catch,
        "receive" => Token::Receive,
        "fallback" => Token::Fallback,
        "as" => Token::As,
        "is" => Token::Is,
        "abstract" => Token::Abstract,
        "virtual" => Token::Virtual,
        "override" => Token::Override,
        "using" => Token::Using,
        "modifier" => Token::Modifier,
        "immutable" => Token::Immutable,
        "unchecked" => Token::Unchecked,
        "assembly" => Token::Assembly,
        "let" => Token::Let,
        "leave" => Token::Leave,
        "switch" => Token::Switch,
        "case" => Token::Case,
        "default" => Token::Default,
        "persistent" => Token::Persistent,
        "temporary" => Token::Temporary,
        "instance" => Token::Instance,
    }
}
