use crate::ast::*;
use crate::error::LexicalError;
use crate::token::Token;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, LexicalError>>);

pub Program: Program = {
    SourceUnit* => Program(<>)
}

SourceUnit: SourceUnit = {
    PragmaDirective => SourceUnit::PragmaDirective(<>.into()),
    ContractDefinition => SourceUnit::ContractDefinition(<>),
    VariableDefinition => SourceUnit::VariableDefinition(<>),
    FunctionDefinition => SourceUnit::FunctionDefinition(<>),
    ";" => SourceUnit::StraySemicolon,
}

PragmaDirective: PragmaDirective = {
    "pragma" <i:Identifier> <comp:VersionComparator1+> ";" => {
        PragmaDirective::Version(i, comp)
    }
}

VersionComparator1: VersionComparator = {
    <left:VersionComparator1> "||" <right:VersionComparator> => VersionComparator::Or {
        left: left.into(),
        right: right.into()
    },
    VersionComparator
}

VersionComparator: VersionComparator = {
    <version:Version> => VersionComparator::Plain {version},
    <op:VersionOp> <version:Version> => VersionComparator::Operator { op, version },
    <from:Version> "-" <to:Version> => VersionComparator::Range { from, to },
}

Version: String = {
    <v: number> => v.to_string()
}

VersionOp: VersionOp = {
    "=" => VersionOp::Exact,
    ">" => VersionOp::Greater,
    ">=" => VersionOp::GreaterEq,
    "<" => VersionOp::Less,
    "<=" => VersionOp::LessEq,
    "~" => VersionOp::Tilde,
    "^" => VersionOp::Caret,
    "*" => VersionOp::Wildcard,
}

ContractDefinition: Box<ContractDefinition> = {
    <ty:ContractTy> <name:Identifier> "{" <parts:(<ContractPart>)*> "}" => {
        Box::new(ContractDefinition{ ty, name, parts })
    }
}

ContractTy: ContractTy = {
    "contract" => ContractTy::Contract,
}

ContractPart: ContractPart = {
    VariableDefinition => ContractPart::VariableDefinition(<>),
    FunctionDefinition => ContractPart::FunctionDefinition(<>),
    ModifierDefinition => ContractPart::FunctionDefinition(<>),
    ConstructorDefinition => ContractPart::FunctionDefinition(<>),
    ";" => ContractPart::StraySemicolon,
}

VariableDefinition: Box<VariableDefinition> = {
    <ty:NoFunctionTyPrecedence0> <attrs:VariableAttribute*> <name:SolIdentifierOrError> <e:("=" <Expression>)?> ";" => {
        Box::new(VariableDefinition{ ty, attrs, name, initializer: e})
    },
    <ty:NoFunctionTyPrecedence0> <attrs:VariableAttribute*> <name:Identifier> <false_token:!> ";" => {
        errors.push (false_token);
        Box::new(VariableDefinition{
            ty, attrs, name: Some(name), initializer: None,
        })
    },
}

VariableAttribute: VariableAttribute = {
    Visibility => VariableAttribute::Visibility(<>),
    StorageType => VariableAttribute::StorageType(<>),
    "constant" => VariableAttribute::Constant,
    "immutable" => VariableAttribute::Immutable,
    "override" => VariableAttribute::Override(Vec::new()),
    "override" "(" <list:CommaOne<SolIdentifierPath>> ")" => {
        VariableAttribute::Override(list)
    }
}

Visibility: Visibility = {
    "public" => Visibility::Public,
    "external" => Visibility::External,
    "internal" => Visibility::Internal,
    "private" => Visibility::Private
}

StorageType: StorageType = {
    "persistent" => StorageType::Persistent,
    "temporary" => StorageType::Temporary,
    "instance" => StorageType::Instance,
}

FunctionDefinition: Box<FunctionDefinition> = {
    "function" <name:SolIdentifierOrError> <params:ParameterList>
    <attributes:FunctionAttribute*>
    <returns:(returns ParameterList)?> <body:BlockStatementOrSemiColon> => {
        let (_, returns) = returns.unwrap_or((None, Vec::new()));

        Box::new(FunctionDefinition{
            ty: FunctionTy::Function,
            name,
            params,
            attributes,
            returns,
            body,
        })
    },
}

// Modifiers can't have attributes or return values, but we parse them anyway so we can give nice
// error messages. The parameter list is optional
ModifierDefinition: Box<FunctionDefinition> = {
    "modifier" <name:Identifier> <params:ParameterList?>
    <attributes:FunctionAttribute*>
   <returns:(returns ParameterList)?> <body:BlockStatementOrSemiColon> => {
        let params = params.unwrap_or(Vec::new());
        let (_, returns) = returns.unwrap_or((None, Vec::new()));

        Box::new(FunctionDefinition{
            ty: FunctionTy::Modifier,
            name: Some(name),
            params,
            attributes,
            returns,
            body
        })
    },
}

ConstructorDefinition: Box<FunctionDefinition> = {
    <ty:FunctionTy> <name:Identifier?> <params:ParameterList>
    <attributes:FunctionAttribute*>
    <returns:(returns ParameterList)?> <body:BlockStatementOrSemiColon> => {
        let (_, returns) = returns.unwrap_or((None, Vec::new()));

        Box::new(FunctionDefinition{
            ty,
            name,
            params,
            attributes,
            returns,
            body
        })
    },
}

// Modifier and function have special case
FunctionTy: FunctionTy = {
    "fallback" => FunctionTy::Fallback,
    "receive" => FunctionTy::Receive,
    "constructor" => FunctionTy::Constructor,
}

BlockStatementOrSemiColon: Option<Statement> = {
    ";" => None,
}

ParameterList: Vec<Option<Parameter>> = {
    "(" ")" => Vec::new(),
    "(" <p:Parameter> ")" => vec!(Some(p)),
    "(" <CommaTwo<OptParameter>> ")" => <>,
    "(" <false_token:!> ")"=> {
        errors.push(<>);
        Vec::new()
    }
}

// A parameter list is used for function arguments and return.
// Destructure statements utilize NamedParameter, not Parameter
Parameter: Parameter = {
    <annotation:ParameterAnnotation?> <ty:Precedence0> <storage:StorageLocation?> <name:Identifier?> => {
        Parameter{annotation, ty, storage, name}
    }
}

OptParameter: Option<Parameter> = {
    <p:Parameter?> => <>,
}

ParameterAnnotation: Annotation = {
    <id:SolAnnotation> => Annotation { id, value: None }
}

FunctionAttribute: FunctionAttribute = {
    Mutability => FunctionAttribute::Mutability(<>),
    Visibility => FunctionAttribute::Visibility(<>),
    "immutable" => FunctionAttribute::Immutable,
    "virtual" => FunctionAttribute::Virtual,
    "override" => FunctionAttribute::Override(Vec::new()),
    "override" "(" <list:CommaOne<SolIdentifierPath>> ")" => {
        FunctionAttribute::Override(list)
    },
    <base:Base> => FunctionAttribute::BaseOrModifier( base),
    <false_token:!> => {
        errors.push(false_token);
        FunctionAttribute::Error
    },
}

returns: Option<String> = {
    "returns" => Some("returns".to_string()),
    "return" => Some("return".to_string())
}

StorageLocation: StorageLocation = {
    "memory" => StorageLocation::Memory,
    "storage" => StorageLocation::Storage,
    "calldata" => StorageLocation::Calldata,
}

Mutability: Mutability = {
    "pure" => Mutability::Pure,
    "constant" => Mutability::Constant,
    "view" => Mutability::View,
    "payable" => Mutability::Payable,
}

Expression: Expression = {
    Precedence14,
}

Precedence14: Expression = {
    <l:Precedence13> "=" <r:Precedence14> => Expression::Assign(Box::new(l), Box::new(r)),
    <l:Precedence13> "|=" <r:Precedence14> => Expression::AssignOr(Box::new(l), Box::new(r)),
    <l:Precedence13> "^=" <r:Precedence14> => Expression::AssignXor(Box::new(l), Box::new(r)),
    <l:Precedence13> "&=" <r:Precedence14> => Expression::AssignAnd(Box::new(l), Box::new(r)),
    <l:Precedence13> "<<=" <r:Precedence14> => Expression::AssignShiftLeft(Box::new(l), Box::new(r)),
    <l:Precedence13> ">>=" <r:Precedence14> => Expression::AssignShiftRight(Box::new(l), Box::new(r)),
    <l:Precedence13> "+=" <r:Precedence14> => Expression::AssignAdd(Box::new(l), Box::new(r)),
    <l:Precedence13> "-=" <r:Precedence14> => Expression::AssignSubtract(Box::new(l), Box::new(r)),
    <l:Precedence13> "*=" <r:Precedence14> => Expression::AssignMultiply(Box::new(l), Box::new(r)),
    <l:Precedence13> "/=" <r:Precedence14> => Expression::AssignDivide(Box::new(l), Box::new(r)),
    <l:Precedence13> "%=" <r:Precedence14> => Expression::AssignModulo(Box::new(l), Box::new(r)),
    <c:Precedence13> "?" <l:Precedence14> ":" <r:Precedence14> => {
        Expression::ConditionalOperator(Box::new(c), Box::new(l), Box::new(r))
    },
    Precedence13,
}

Precedence13: Expression = {
    <l:Precedence13> "||" <r:Precedence12> => Expression::Or(Box::new(l), Box::new(r)),
    Precedence12,
}

Precedence12: Expression = {
    <l:Precedence12> "&&" <r:Precedence11> => Expression::And(Box::new(l), Box::new(r)),
    Precedence11,
}

Precedence11: Expression = {
    <l:Precedence11> "==" <r:Precedence10> => Expression::Equal(Box::new(l), Box::new(r)),
    <l:Precedence11> "!=" <r:Precedence10> => Expression::NotEqual(Box::new(l), Box::new(r)),
    Precedence10,
}

Precedence10: Expression = {
    <l:Precedence10> "<" <r:Precedence9> => Expression::Less(Box::new(l), Box::new(r)),
    <l:Precedence10> ">" <r:Precedence9> => Expression::More(Box::new(l), Box::new(r)),
    <l:Precedence10> "<=" <r:Precedence9> => Expression::LessEqual(Box::new(l), Box::new(r)),
    <l:Precedence10> ">=" <r:Precedence9> => Expression::MoreEqual(Box::new(l), Box::new(r)),
    Precedence9,
}

Precedence9: Expression = {
    <l:Precedence9> "|" <r:Precedence8> => Expression::BitwiseOr(Box::new(l), Box::new(r)),
    Precedence8,
}

Precedence8: Expression = {
    <l:Precedence8> "^" <r:Precedence7> => Expression::BitwiseXor(Box::new(l), Box::new(r)),
    Precedence7,
}

Precedence7: Expression = {
    <l:Precedence7> "&" <r:Precedence6> => Expression::BitwiseAnd(Box::new(l), Box::new(r)),
    Precedence6,
}

Precedence6: Expression = {
    <l:Precedence6> "<<" <r:Precedence5> => Expression::ShiftLeft(Box::new(l), Box::new(r)),
    <l:Precedence6> ">>" <r:Precedence5> => Expression::ShiftRight(Box::new(l), Box::new(r)),
    Precedence5,
}

Precedence5: Expression = {
    <l:Precedence5> "+" <r:Precedence4> => Expression::Add(Box::new(l), Box::new(r)),
    <l:Precedence5> "-" <r:Precedence4> => Expression::Subtract(Box::new(l), Box::new(r)),
    Precedence4,
}

Precedence4: Expression = {
    <l:Precedence4> "*" <r:Precedence3> => Expression::Multiply(Box::new(l), Box::new(r)),
    <l:Precedence4> "/" <r:Precedence3> => Expression::Divide(Box::new(l), Box::new(r)),
    <l:Precedence4> "%" <r:Precedence3> => Expression::Modulo(Box::new(l), Box::new(r)),
    Precedence3,
}

Precedence3: Expression = {
    <l:Precedence2> "**" <r:Precedence3> => Expression::Power(Box::new(l), Box::new(r)),
    Precedence2,
}

Precedence2: Expression = {
    "!" <e:Precedence2> => Expression::Not(Box::new(e)),
    "~" <e:Precedence2> => Expression::BitwiseNot(Box::new(e)),
    "delete" <e:Precedence2>  => Expression::Delete(Box::new(e)),
    "new" <call:Precedence2> => Expression::New(Box::new(call)),
    "++" <e:Precedence2> => Expression::PreIncrement(Box::new(e)),
    "--" <e:Precedence2> => Expression::PreDecrement(Box::new(e)),
    "+" <e:Precedence2>  => Expression::UnaryPlus(Box::new(e)),
    "-" <e:Precedence2> => Expression::Negate(Box::new(e)),
    "revert" => Expression::Variable(Identifier{name: "revert".to_string()}),

    Precedence1
}

Precedence1: Expression = {
    <n:number> <unit:SolNoRevertIdentifier?> => {
        Expression::NumberLiteral(n.to_string(), unit)
    },
    <n:rational> <unit:SolNoRevertIdentifier?> => {
        Expression::RationalNumberLiteral(n.to_string(), unit)
    },
    <n:hexnumber> <unit:SolNoRevertIdentifier?> => {
        Expression::HexNumberLiteral(n.to_owned(), unit)
    },
    Precedence0
}

Precedence0: Expression = {
    NoFunctionTyPrecedence0,
}

NoFunctionTyPrecedence0: Expression = {
    <e:Precedence1> "++" => Expression::PostIncrement(Box::new(e)),
    <e:Precedence1> "--" => Expression::PostDecrement(Box::new(e)),
    <e:Precedence1> "[" <i:Expression?> "]" => Expression::ArraySubscript(Box::new(e), i.map(Box::new)),
    <e:Precedence1> "[" <l:Expression?> ":" <r:Expression?> "]" => Expression::ArraySlice(Box::new(e), l.map(Box::new), r.map(Box::new)),
    <e:Precedence1> "." <i:Identifier> => Expression::MemberAccess(Box::new(e), i),
    // Solidity has ".address" members on external function types. Address is a keyword, so special casing needed
    <e:Precedence1> "." "address" => {
        Expression::MemberAccess(Box::new(e),
            Identifier { name: "address".to_string() })
    },
    <e:Precedence1> "." "new" => {
        Expression::MemberAccess(Box::new(e),
            Identifier { name: "new".to_string() })
    },
    "[" <v:Comma<Expression>> "]" => {
        Expression::ArrayLiteral(v)
    },
    <SolNoRevertIdentifier> => Expression::Variable(<>),
    LiteralExpression
}

NamedArgument: NamedArgument = {
    <name:Identifier> ":" <expr:Expression> => {
        NamedArgument{ name, expr }
    },
    "address" ":" <expr:Expression> => {
        NamedArgument{ name: Identifier { name: "address".into() }, expr }
    },
}

LiteralExpression: Expression = {
    "true" => Expression::BoolLiteral(true),
    "false" => Expression::BoolLiteral(false),
    <StringLiteral+> => Expression::StringLiteral(<>),
    <HexLiteral+> => Expression::HexLiteral(<>),
    <a:address> => {
        let v = a.to_string();
        let address_len = a.len() - 9;

        Expression::AddressLiteral(a.chars().skip(8).filter(|c|  *c != '"' && *c != '\'').collect())
    },
}

StringLiteral: StringLiteral = {
    <s:string> => {
        let (unicode, string) = if s.starts_with("unicode") {
            (true, s[8..s.len()-1].to_string())
        } else {
            (false, s[1..s.len()-1].to_string())
        };
        StringLiteral{ unicode, string }
    }
}

HexLiteral: HexLiteral = {
    <s:hexstring> => {
        let v = s.to_string();
        let hex_len = v.len() - 5;

        HexLiteral{ hex: v.chars().skip(4).filter(|c| *c != '_' && *c != '"' && *c != '\'').collect() }
    }
}

Identifier: Identifier = {
    <n:identifier> => Identifier{ name: n.to_string() }
}

SolNoRevertIdentifier: Identifier = {
    <n:identifier> => Identifier{name: n.to_string()},
    "switch" => Identifier{name: "switch".to_string()},
    "leave" => Identifier{name: "leave".to_string()},
    "case" => Identifier{name: "case".to_string()},
    "default" => Identifier{name: "default".to_string()},
}

SolAnnotation: Identifier = {
    <a:annotation> => Identifier{ name: a.to_string() },
}

SolIdentifierOrError: Option<Identifier> = {
    Identifier => Some(<>),
    ! => {
        errors.push(<>);
        None
    }
}

SolIdentifierPath: IdentifierPath = {
    <e:Identifier> <v:("." <Identifier>)*> => {
        let mut v = v;
        v.insert(0, e);
        IdentifierPath { identifiers: v }
    }
}

Base: Base = {
    <name:SolIdentifierPath> <args:("(" <Comma<Expression>> ")")?> => Base { name, args }
}

Comma<T>: Vec<T> = {
    => Vec::new(),
    CommaOne<T> => <>,
};

CommaOne<T>: Vec<T> = {
    <e:T> <v:("," <T>)*> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

CommaTwo<T>: Vec<T> = {
    <e:T> <v:("," <T>)+> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        identifier => Token::Identifier(<String>),
        annotation => Token::Annotation(<String>),
        string => Token::StringLiteral(<String>),
        hexstring => Token::HexLiteral(<String>),
        address => Token::AddressLiteral(<String>),
        number => Token::Number(<f64>),
        rational => Token::RationalNumber(<String>),
        hexnumber => Token::HexNumber(<String>),

        ";" => Token::Semicolon,
        "{" => Token::OpenCurlyBrace,
        "}" => Token::CloseCurlyBrace,
        "(" => Token::OpenParenthesis,
        ")" => Token::CloseParenthesis,
        "=" => Token::Assign,
        "==" => Token::Equal,
        "=>" => Token::Arrow,
        "->" => Token::YulArrow,
        "|=" => Token::BitwiseOrAssign,
        "^=" => Token::BitwiseXorAssign,
        "&=" => Token::BitwiseAndAssign,
        "<<=" => Token::ShiftLeftAssign,
        ">>=" => Token::ShiftRightAssign,
        "+=" => Token::AddAssign,
        "-=" => Token::SubtractAssign,
        "*=" => Token::MulAssign,
        "/=" => Token::DivideAssign,
        "%=" => Token::ModuloAssign,
        "?" => Token::Question,
        ":" => Token::Colon,
        ":=" => Token::ColonAssign,
        "||" => Token::Or,
        "&&" => Token::And,
        "!=" => Token::NotEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        ">" => Token::More,
        ">=" => Token::MoreEqual,
        "|" => Token::BitwiseOr,
        "&" => Token::BitwiseAnd,
        "^" => Token::BitwiseXor,
        "<<" => Token::ShiftLeft,
        ">>" => Token::ShiftRight,
        "+" => Token::Add,
        "-" => Token::Subtract,
        "*" => Token::Mul,
        "/" => Token::Divide,
        "%" => Token::Modulo,
        "**" => Token::Power,
        "!" => Token::Not,
        "~" => Token::BitwiseNot,
        "++" => Token::Increment,
        "--" => Token::Decrement,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "." => Token::Member,
        "," => Token::Comma,
        Uint => Token::Uint(<u16>),
        Int => Token::Int(<u16>),
        Bytes => Token::Bytes(<u8>),
        "byte" => Token::Byte,
        "struct" => Token::Struct,
        "memory" => Token::Memory,
        "calldata" => Token::Calldata,
        "storage" => Token::Storage,
        "import" => Token::Import,
        "contract" => Token::Contract,
        "pragma" => Token::Pragma,
        "bool" => Token::Bool,
        "address" => Token::Address,
        "string" => Token::String,
        "bytes" => Token::DynamicBytes,
        "delete" => Token::Delete,
        "new" => Token::New,
        "interface" => Token::Interface,
        "library" => Token::Library,
        "event" => Token::Event,
        "enum" => Token::Enum,
        "type" => Token::Type,
        "public" => Token::Public,
        "private" => Token::Private,
        "external" => Token::External,
        "internal" => Token::Internal,
        "constant" => Token::Constant,
        "true" => Token::True,
        "false" => Token::False,
        "pure" => Token::Pure,
        "view" => Token::View,
        "payable" => Token::Payable,
        "constructor" => Token::Constructor,
        "function" => Token::Function,
        "returns" => Token::Returns,
        "return" => Token::Return,
        "revert" => Token::Revert,
        "if" => Token::If,
        "for" => Token::For,
        "while" => Token::While,
        "else" => Token::Else,
        "do" => Token::Do,
        "continue" => Token::Continue,
        "break" => Token::Break,
        "throw" => Token::Throw,
        "emit" => Token::Emit,
        "anonymous" => Token::Anonymous,
        "indexed" => Token::Indexed,
        "mapping" => Token::Mapping,
        "try" => Token::Try,
        "catch" => Token::Catch,
        "receive" => Token::Receive,
        "fallback" => Token::Fallback,
        "as" => Token::As,
        "is" => Token::Is,
        "abstract" => Token::Abstract,
        "virtual" => Token::Virtual,
        "override" => Token::Override,
        "using" => Token::Using,
        "modifier" => Token::Modifier,
        "immutable" => Token::Immutable,
        "unchecked" => Token::Unchecked,
        "assembly" => Token::Assembly,
        "let" => Token::Let,
        "leave" => Token::Leave,
        "switch" => Token::Switch,
        "case" => Token::Case,
        "default" => Token::Default,
        "persistent" => Token::Persistent,
        "temporary" => Token::Temporary,
        "instance" => Token::Instance,
    }
}
